<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title><type>int ***</type> háromszögmátrix</title>
        <para>
           
        </para>
<programlisting language="c"><![CDATA[
#include <stdio.h>
#include <stdlib.h>

int
main ()
{
    int rs = 5;
    double **tb;
    
    printf("%p\n", &tb);
    
    if ((tb = (double **) malloc (rs * sizeof (double *))) == NULL)
    {
        return -1;
    }

    printf("%p\n", tb);
    
    for (int i = 0; i < rs; ++i)
    {
        if ((tb[i] = (double *) malloc ((i + 1) * sizeof (double))) == NULL)
        {
            return -1;
        }

    }

    printf("%p\n", tb[0]);    
    
    for (int i = 0; i < rs; ++i)
        for (int j = 0; j < i + 1; ++j)
            tb[i][j] = i * (i + 1) / 2 + j;

    for (int i = 0; i < rs; ++i)
    {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tb[i][j]);
        printf ("\n");
    }

    tb[3][0] = 42.0;
    (*(tb + 3))[1] = 43.0;
    *(tb[3] + 2) = 44.0;
    *(*(tb + 3) + 3) = 45.0;

    for (int i = 0; i < rs; ++i)
    {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tb[i][j]);
        printf ("\n");
    }

    for (int i = 0; i < rs; ++i)
        free (tb[i]);

    free (tb);

    return 0;
}
]]>
</programlisting>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:    <link xlink:href="https://github.com/lovaszbotond/Caesar/blob/master/int**"></link>            
        </para>
        <para>
           A feladatot a szokásos módon, a headerben a megfelelő függvénykönyvtárak behívásával kezdtük el.Létrehoztuk a <function> rs = 5 </function>-el  a sorainknak a számát amire szükségünk van.A <function>double **tb</function> deklarálunk és lefoglalunk a memóriában 8 byte-ot jelen esetben.Majd szimplán egy kiíratást végzünk . A <function>%p</function> segítségével egy hexadecimális számot fogunk ki írni mely a pointer számát fogja adni. Az adott sorban a vessző után látjuk , hogy a cimkéző operátor segítségével 1 bájt címét fogjuk ki íratni.Konkrétan lekérdezzük a címét.
A <function>malloc</function> vissza ad egy pointert a lefoglalt területre. Memóriát foglal a szabad tárban. Kap egy paramétert ami az rs függvényében zajlik.(5)Következőkben látjuk , hogy a <function>size of (double*)</function>megmondja hogy mennyi hely(byte) kell a double* típusnak, ami a feladatban 5*8 azaz 40 byte helyet fog lefoglalni.Egyébként ami vissza kapunk ponter bármire mutathat a malloc esetében.Típus kényszerítjük ami miatt a "size of" méretét fogja vissza adni. A <function>tb</function>egyenlő a malloc által vissza adott értékkel memória foglalás szempontjából.Ha bármilyen hiba merülne fel akkor pedig a program kilép. Ezt biztosítjuk a <function>==NULL</function> szekcióban.A <function>NULL</function> nem mutat sehova.A folytatásban megkreáljuk az 5 sorból álló háromszögünket.Nagyon jól lehet szemléltetni a hivatkozásainkat , hogyan és miként működnek. 
Lehet látni , hogy a <function>tb[3][0] = 42.0</function>a harmadik sor első elemét egyenlővé tesszük 42.00-val. Azért az első eleme, erről még nem beszáltünk, mert 0-tól kezdjük a számolást/indexelést.Az alatta lévő sorban a második elemre hivatkozunk, alatta a harmadik elemre, majd a negyedik elemre.A "*" al hivatkozok azon a címen tárolt pointerre.Tökéletesen reprezentálja a példa mily módon és hányféleképpen tudunk hivatkozni.A <function>for</function>ciklusukhoz különösképpen nem tudunk kiegészítést írni . A Chomsky fejezetünkben a hivatkozásos példánál kiveséztük nagy részét és a lényeg megtalálható benne ami ezen feladat megértéséhez kell.Amit esetlek meglehet említeni a <function>tb[i][j]</function>ahol az "i" a sor a "j" pedig az oszlopot jelzik.Fontos hogy vizsgáljuk a kapcsos zárójelek elhelyezkedését,hisz úgy fogjuk meg érteni mikor mi hajtódik végbe.A <function>%f</function> egy float típusú változót fog vissza adni.A végén a <function>free</function>-ről kell pár sort írnunk.Lényegében felszabadítja a memóriában tárolt/lévő dolgokat. Ez fontos, hogy ne maradjon meg az adat amit tárol , mert ha a program még dolgozna tovább és ezt nem tennénk meg akkor egy idő után betelne a ram.
        </para>            
    </section>        
    <section>
        <title>C EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót C-ben!
        </para>
<programlisting language="c"><![CDATA[
#include <stdio.h>
#include <unistd.h>
#include <string.h>

#define MAX_KULCS 100
#define BUFFER_MERET 256


int
main (int argc, char **argv)
{

  char kulcs[MAX_KULCS];
  char buffer[BUFFER_MERET];

  int kulcs_index = 0;
  int olvasott_bajtok = 0;

  int kulcs_meret = strlen (argv[1]);
  strncpy (kulcs, argv[1], MAX_KULCS);

  while ((olvasott_bajtok = read (0, (void *) buffer, BUFFER_MERET)))
    {

      for (int i = 0; i < olvasott_bajtok; ++i)
	{

	  buffer[i] = buffer[i] ^ kulcs[kulcs_index];
	  kulcs_index = (kulcs_index + 1) % kulcs_meret;

	}

      write (1, buffer, olvasott_bajtok);

    }
}]]></programlisting>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/lovaszbotond/Caesar/blob/master/Exor%20titkos%C3%ADt%C3%B3%20e.c"></link>                
        </para>
        <para>
           Maga a program ahogy a feladat is kéri egy titkosító lesz melyhez egy x hosszu kulcsot megadba titkosíthatunk szövegeket.Megismerkedünk a headerben egy nem "#include"-al kezdődő pre-compiler által fordított függvénykönyvtárral,ami a nevéből adódóan is látjuk , hogy definíció.Nem is kell túlgondolnunk definiáljuk , hogy a <function>MAX_KULCS</function> = 100 és ezt nem fogjuk tudnu a mainen belül megváltoztatni.Szintúgy a <function>BUFFER_MERET</function>-et 256-al tesszük egyenlővé.Megadja mennyit tud egyszerre beolvasni(hány darab karaktert).Az <function>argc</function> megmondja hogy a programot hány szóval hívtam meg/fordítottam le. Tegyük fel |gcc e.c -o k.c|  akkor a spacek száma plusz 1 lesz az argc, ami jelenleg a példánkban 4.Az <function>argv</function> tárolja az argumentumokat.A <function>char</function> variable egy nagyon pici 1 byte-os történet.Karaktereket deklarálunk vele.A programban a "max_kulcs", illetve a buffer amit beállítottunk neki.A kulcs méret amivel folytathatjuk. A <function>strlen</function> a string.h-ban találjuk meg , és a megadott string, hogy hány karakter hosszú azt mondja meg. A <function>strncpy</function> "string copy" pedig hogy mibe, mit , milyen hosszút. A <function>while</function> ciklusban végigolvassa a szöveget a "read" segítségével ami egészen addig olvassa a fájlt, míg a fájl vége jellel nem találkozik.Majd ha megtalálta lelövi a programot. A "buffer" méretnyit olvassa be. A write pedig ki írja az olvasott byteokat. A "return 0;" nem kell a program végére, mert elvégzi a feladatot és off.
        </para>            
    </section>        
    <section>
        <title>Java EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót Java-ban!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
    <section>
        <title>C EXOR törő</title>
        <para>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
        </para>
<programlisting language="c"><![CDATA[
#define MAX_TITKOS 4096
#define OLVASAS_BUFFER 256
#define KULCS_MERET 5
#define _GNU_SOURCE

#include <stdio.h>
#include <unistd.h>
#include <string.h>

double
atlagos_szohossz (const char *titkos, int titkos_meret)
{
  int sz = 0;
  for (int i = 0; i < titkos_meret; ++i)
    if (titkos[i] == ' ')
      ++sz;

  return (double) titkos_meret / sz;
}

int
tiszta_lehet (const char *titkos, int titkos_meret)
{
  // a tiszta szoveg valszeg tartalmazza a gyakori magyar szavakat
  // illetve az átlagos szóhossz vizsgálatával csökkentjük a
  // potenciális töréseket

  double szohossz = atlagos_szohossz (titkos, titkos_meret);

  return szohossz > 5.0 && szohossz < 9.0
    && strcasestr (titkos, "hogy") && strcasestr (titkos, "nem")
    && strcasestr (titkos, "az") && strcasestr (titkos, "ha");

}

void
exor (const char kulcs[], int kulcs_meret, char titkos[], int titkos_meret)
{

  int kulcs_index = 0;

  for (int i = 0; i < titkos_meret; ++i)
    {

      titkos[i] = titkos[i] ^ kulcs[kulcs_index];
      kulcs_index = (kulcs_index + 1) % kulcs_meret;

    }

}

int
exor_tores (const char kulcs[], int kulcs_meret, char titkos[],
	    int titkos_meret)
{

  exor (kulcs, kulcs_meret, titkos, titkos_meret);

  return tiszta_lehet (titkos, titkos_meret);

}

int
main (void)
{

  char kulcs[KULCS_MERET];
  char titkos[MAX_TITKOS];
  char *p = titkos;
  int olvasott_bajtok;

  // titkos fajt berantasa
  while ((olvasott_bajtok =
	  read (0, (void *) p,
		(p - titkos + OLVASAS_BUFFER <
		 MAX_TITKOS) ? OLVASAS_BUFFER : titkos + MAX_TITKOS - p)))
    p += olvasott_bajtok;

  // maradek hely nullazasa a titkos bufferben  
  for (int i = 0; i < MAX_TITKOS - (p - titkos); ++i)
    titkos[p - titkos + i] = '\0';

  // osszes kulcs eloallitasa
  for (int ii = 'a'; ii <= 'z'; ++ii)
    for (int ji = 'a'; ji <= 'z'; ++ji)
      for (int ki = 'a'; ki <= 'z'; ++ki)
	for (int li = 'a'; li <= 'z'; ++li)
	  for (int mi = 'a'; mi <= 'z'; ++mi)
	   
		  {
		    kulcs[0] = ii;
		    kulcs[1] = ji;
		    kulcs[2] = ki;
		    kulcs[3] = li;
		    kulcs[4] = mi;
		  

		    if (exor_tores (kulcs, KULCS_MERET, titkos, p - titkos))
		      printf
			("Kulcs: [%c%c%c%c%c]\nTiszta szoveg: [%s]\n",
			 ii, ji, ki, li, mi,  titkos);

		    // ujra EXOR-ozunk, igy nem kell egy masodik buffer  
		    exor (kulcs, KULCS_MERET, titkos, p - titkos);
		  }

  return 0;
}]]></programlisting>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/lovaszbotond/Caesar/blob/master/Exor%20titkos%C3%ADt%C3%B3%20t.c"></link>                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            R
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
            C++
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
